# .NET Knowledge Improvements

## Книги


1. https://yadi.sk/i/lLKAsJpvTQ2x_A
Рихтер
Не рекомендовал бы использовать его неоспоримую истину - у него есть неточности про GC и про параллелизм я отдельно буду уделять этому внимание когда будем глубоко обсуждать эти темы, но основы у него изложены хорошо

2. https://docs.microsoft.com/ru-ru/dotnet/standard/
Официальная документация MS

3. https://yadi.sk/i/Hp6BumIE3Vge3f
С# 7 in a nutshell. Хорошая книга по основным темам, но некоторые моменты все равно рассказаны поверхностно

4. https://yadi.sk/i/iR9hfATmTJQByw
Джон Скит. Хорошая книга по основным темам, с достаточно глубокими деталями

5. https://yadi.sk/i/iR9hfATmTJQByw
Книга по работе GC

6. https://yadi.sk/i/s7p_gUpQeZ5Hbg
Книга Стефана Клери про параллелизм. Рекомендуется читать как дополнение к тому что написано про эту тему в других книгах

7. https://github.com/dotnet
https://github.com/microsoft/referencesource
Сурсы от MS


## Тест
1. Почему структуры принято делать неизменяемыми (например DateTime). Потому что они передаются по значению, а не по ссылке, копируются
    И что выведет на консоль данный код и почему: 42. когда прикастим - создадим новый объект в куче и будем менять его

2. ref - передача по ссылке, когда нужно поменять переменную, out - когда хотим вернуть значения

3. Переменная должна быть проинициализирована. Бля, ошибся, код валидный :(

4. Equals - на null, на GetType, потом возможно по референс EQ, потом возможно IEquitable, хз

5. (object)i == (object)j. Это boxed-значения. Они НЕ равны.

6. реф строки: s1=11, s2=1;


## 1. Очередь
ДЗ написать собственную реализацию потокобезопасной очереди для типа Object не используя готовые коллекции из BCL
Должны быть реализованы методы Dequeue, возвращающий элемент или кидающий ошибку что очередь пуста и метод Enqueue добавляющий элементы и свойство Count
И тесты проверяющие что очередь работает правильно

## 2. LeftJoin
Задание - есть 2 коллекции
 Item1: ID, Value, Details (ID, Value заполненго, поле Details не заполнено)
 Item2: ID, Details (ID , Details заполнено)
 Нужно реализовать оператор LeftJoin(IEnumerable<Item1>, IEnumerable<Item2>) который бы заполнил данные в коллекции 1 из коллекции 2
 Оператор должен возвращать IEnumerable<Item1> 
 Внутри метода LeftJoin нельзя использовать коллекции и yield